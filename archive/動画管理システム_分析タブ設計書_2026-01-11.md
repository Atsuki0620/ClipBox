# 動画管理システム 分析タブ設計書

作成日: 2026年1月11日  
バージョン: 1.0

---

## 1. 分析タブの位置づけと設計思想

### 1.1 目的と役割

分析タブは、動画ライブラリの状態を統計的に把握するための**読み取り専用ダッシュボード**として設計する。個別動画の探索や再生を担う「動画一覧」タブとは役割を分離し、以下の価値を提供する：

- **ライブラリの構成把握**: レベル別・保存先別の動画数と容量の分布
- **視聴の偏り可視化**: 視聴回数の分布、視聴済み/未視聴の比率
- **保管場所の使い分け確認**: CドライブとHDDの利用状況
- **お気に入りレベルの妥当性検証**: レベル別の視聴傾向から判断材料を提供

### 1.2 基本方針

**読み取り専用**
- データベースを書き換える操作（レベル更新、削除フラグ変更等）は一切行わない
- 閲覧と探索に徹し、操作系機能は他タブに分離

**探索型ダッシュボード**
- スコープ（利用可能/不可、削除済み含む/除外）や期間を切り替え可能
- 同じ指標体系で結果が動的に更新される設計
- 「単一の固定ビュー」ではなく、ユーザーが条件を調整しながら理解を深める

**シンプルさと一貫性の優先**
- 集計の意味がぶれない設計
- UIを過剰に複雑化させず、主要な判断が素早くできることを重視

---

## 2. データスコープとフィルタ仕様

### 2.1 is_available フィルタ（主要フィルタ）

**概要**: 動画の利用可能性に基づくスコープ選択

**選択肢**:
- `利用可能のみ` (is_available = 1) ← **既定値**
- `利用不可のみ` (is_available = 0)
- `すべて` (is_available = 0 or 1)

**既定値の理由**:
外付けHDDの接続状態に左右されるライブラリにおいて、分析タブを開いた直後に「今すぐ再生できる棚」の状態を見ることが最も有用であるため。利用不可を含む全体俯瞰は必要に応じて切り替えれば十分。

**動作**:
- フィルタ変更時、全KPI・グラフ・ランキングが選択されたスコープで再計算される
- 比較表示（利用可/不可を並べる）は行わず、選択された集合を単一集計として表示

### 2.2 is_deleted フィルタ（トグル）

**概要**: 削除済み動画の含む/除外を切り替え

**選択肢**:
- `削除済みを除外` (is_deleted = 0) ← **既定値**
- `削除済みを含む` (is_deleted = 0 or 1)

**既定値の理由**:
分析タブの主用途は「運用中のライブラリ状態の把握」であり、削除済みの混入は多くの場合ノイズになる。削除済みを含めるのは検証やメンテナンスなど例外的局面に限る想定。

**UI表現**:
- チェックボックスまたはトグルスイッチ
- ラベル: 「削除済みを含む」（チェックで含む、未チェックで除外）

### 2.3 期間フィルタ（プリセット + カスタム）

**概要**: 視聴履歴集計の基準期間を指定

**プリセット選択肢**:
- `全期間` ← **既定値**
- `直近7日`
- `直近30日`
- `直近90日`
- `直近180日`
- `カスタム`（開始日〜終了日を日付範囲ピッカーで指定）

**既定値の理由**:
初回表示では累計での傾向把握が最も汎用的であるため。

**期間フィルタの適用範囲**:
期間フィルタは**視聴回数を用いるすべての指標**に完全連動する：
- 期間内総視聴回数
- 視聴回数ランキング
- レベル別平均視聴回数（該当する場合）
- 視聴回数の推移グラフ

**期間フィルタの非適用範囲**:
以下の指標は期間フィルタの影響を受けない（累計基準で固定）：
- 総動画数
- 総容量
- 視聴済み動画数（累計で1回以上視聴）
- 未視聴動画数（累計視聴回数0）
- レベル別動画数
- レベル別総容量
- 保存先別動画数/容量
- 容量分布

**カスタム期間の仕様**:
- UIコンポーネント: Streamlit `st.date_input` の範囲指定モード
- 入力形式: `(開始日, 終了日)` のタプル
- 境界処理: 開始日の00:00:00 〜 終了日の23:59:59（両端含む）

---

## 3. 視聴回数の定義

### 3.1 基本定義

分析タブにおける「視聴回数」は、`viewing_history` テーブルを基準に算出し、以下の viewing_method を合算した回数とする：

- `APP_PLAYBACK`: アプリ内の再生ボタン経由
- `FILE_ACCESS_DETECTED`: OS側アクセス検知による自動記録

**合算の理由**:
視聴という概念の厳密性よりも、「実際にアクセスされた／再生された」という利用実態の捕捉を優先し、集計軸を一本化して扱いやすくする。

### 3.2 未視聴の定義

**未視聴** = 累計で一度も履歴が存在しない動画（累計視聴回数が0の動画）

**重要な設計決定**:
- 未視聴は「未着手」を意味する概念として固定
- 期間フィルタを変えても未視聴の意味は変わらない（常に累計基準）
- 「期間内未視聴」（過去には視聴したが指定期間では見ていない）という概念は採用しない

**理由**:
未視聴を二系統（生涯未視聴／期間内未視聴）で併存させると解釈が複雑化し、UI設計も煩雑になる。未視聴は常に一つの数字として扱うことで、一貫性と簡潔性を優先する。

### 3.3 視聴済みの定義

**視聴済み** = 累計視聴回数が1回以上の動画

**期間フィルタとの関係**:
- 視聴済み動画数は累計基準であり、期間フィルタの影響を受けない
- 期間フィルタは「視聴回数の集計範囲」を変えるが、「視聴済み/未視聴の判定基準」は変えない

---

## 4. 画面構成とセクション配置

### 4.1 全体レイアウト

分析タブは以下の4セクションを上から順に配置する：

```
┌─────────────────────────────────────────────┐
│ 1. フィルタコントロール領域                  │
│    - スコープ選択 (is_available)            │
│    - 削除済みトグル (is_deleted)            │
│    - 期間選択（プリセット + カスタム）       │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│ 2. KPIサマリー領域                          │
│    - 総動画数、総容量、視聴済み数、未視聴数  │
│    - 期間内総視聴回数                       │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│ 3. グラフ領域                               │
│    - レベル別集計グラフ                     │
│    - 保存先別集計グラフ                     │
│    - 視聴回数の推移グラフ                   │
│    - 視聴済み率円グラフ                     │
│    - 容量分布ヒストグラム                   │
│    - 視聴回数分布（min/maxスライダー付き）   │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│ 4. ランキング領域                           │
│    - 視聴回数ランキング（Top 50）            │
└─────────────────────────────────────────────┘
```

### 4.2 各セクションの詳細仕様

#### 4.2.1 フィルタコントロール領域

**配置**: 画面最上部、横並びレイアウト

**UI コンポーネント**:

```python
col1, col2, col3 = st.columns(3)

with col1:
    availability_filter = st.selectbox(
        "利用可能性",
        options=["利用可能のみ", "利用不可のみ", "すべて"],
        index=0  # 既定値: 利用可能のみ
    )

with col2:
    include_deleted = st.checkbox(
        "削除済みを含む",
        value=False  # 既定値: 除外
    )

with col3:
    period_preset = st.selectbox(
        "期間",
        options=["全期間", "直近7日", "直近30日", "直近90日", "直近180日", "カスタム"],
        index=0  # 既定値: 全期間
    )

# カスタム期間選択時のみ表示
if period_preset == "カスタム":
    date_range = st.date_input(
        "期間を指定",
        value=(datetime.now() - timedelta(days=30), datetime.now()),
        max_value=datetime.now()
    )
```

#### 4.2.2 KPIサマリー領域

**配置**: フィルタ直下、横並び5列レイアウト

**表示指標**:

| 指標名 | 説明 | 期間連動 | スコープ連動 |
|-------|------|---------|------------|
| 総動画数 | スコープに応じた対象動画の総数 | × | ○ |
| 総容量 (GB) | スコープに応じた総容量（GB単位、小数点2桁） | × | ○ |
| 視聴済み数 | 累計視聴回数 ≥ 1 の動画数 | × | ○ |
| 未視聴数 | 累計視聴回数 = 0 の動画数 | × | ○ |
| 期間内総視聴回数 | 指定期間内の視聴イベント総数 | ○ | ○ |

**UI コンポーネント**:

```python
col1, col2, col3, col4, col5 = st.columns(5)

with col1:
    st.metric("総動画数", f"{total_videos:,}本")

with col2:
    st.metric("総容量", f"{total_size_gb:.2f} GB")

with col3:
    st.metric("視聴済み", f"{viewed_videos:,}本")

with col4:
    st.metric("未視聴", f"{unviewed_videos:,}本")

with col5:
    st.metric("期間内総視聴回数", f"{period_view_count:,}回")
```

#### 4.2.3 グラフ領域

**配置**: KPIサマリー直下、2列または1列レイアウト（グラフの種類に応じて）

**グラフ一覧**:

1. **レベル別動画数**（棒グラフ）
2. **レベル別総容量**（棒グラフ）
3. **保存先別動画数**（棒グラフ）
4. **保存先別総容量**（棒グラフ）
5. **視聴回数の推移**（折れ線グラフ、日別/週別/月別切り替え）
6. **視聴済み率**（円グラフ）
7. **容量分布**（ヒストグラム）
8. **視聴回数分布**（ヒストグラム、min/maxスライダー付き）

**詳細仕様は 5章 を参照**

#### 4.2.4 ランキング領域

**配置**: グラフ領域直下

**表示内容**:
- 視聴回数ランキング（Top 50件）
- 期間フィルタに連動
- スコープフィルタに連動

**UI コンポーネント**:

```python
st.subheader("📊 視聴回数ランキング (Top 50)")

# ランキングDataFrameを作成
ranking_df = get_view_count_ranking(
    df_filtered,
    period_start,
    period_end,
    top_n=50
)

# 表示カラム: 順位、ファイル名、レベル、視聴回数
st.dataframe(
    ranking_df[['順位', 'ファイル名', 'お気に入りレベル', '視聴回数']],
    use_container_width=True,
    height=600
)
```

---

## 5. グラフ仕様

### 5.1 レベル別動画数（棒グラフ）

**目的**: お気に入りレベルごとの動画本数を可視化

**データソース**: videos テーブル（スコープフィルタ適用後）

**集計方法**:
```python
level_count = df_filtered.groupby('current_favorite_level').size().reset_index(name='動画数')
```

**グラフ仕様**:
- グラフタイプ: 縦棒グラフ
- X軸: お気に入りレベル (0, 1, 2, 3, 4...)
- Y軸: 動画数
- 色: 単色または レベルごとに色分け

**Streamlit実装例**:
```python
st.subheader("📊 レベル別動画数")
st.bar_chart(level_count.set_index('current_favorite_level'))
```

### 5.2 レベル別総容量（棒グラフ）

**目的**: お気に入りレベルごとの総容量を可視化

**データソース**: videos テーブル（スコープフィルタ適用後）

**集計方法**:
```python
level_size = df_filtered.groupby('current_favorite_level')['file_size'].sum().reset_index()
level_size['容量_GB'] = level_size['file_size'] / (1024**3)
```

**グラフ仕様**:
- グラフタイプ: 縦棒グラフ
- X軸: お気に入りレベル
- Y軸: 総容量 (GB)
- 色: 単色または レベルごとに色分け

**Streamlit実装例**:
```python
st.subheader("💾 レベル別総容量")
st.bar_chart(level_size.set_index('current_favorite_level')['容量_GB'])
```

### 5.3 保存先別動画数（棒グラフ）

**目的**: Cドライブ vs 外付けHDDの動画本数を比較

**データソース**: videos テーブル（スコープフィルタ適用後）

**集計方法**:
```python
storage_count = df_filtered.groupby('storage_location').size().reset_index(name='動画数')
```

**グラフ仕様**:
- グラフタイプ: 縦棒グラフ
- X軸: 保存場所 ('C_DRIVE', 'EXTERNAL_HDD')
- Y軸: 動画数
- 色: 保存先ごとに色分け

**Streamlit実装例**:
```python
st.subheader("📍 保存先別動画数")
st.bar_chart(storage_count.set_index('storage_location'))
```

### 5.4 保存先別総容量（棒グラフ）

**目的**: Cドライブ vs 外付けHDDの総容量を比較

**データソース**: videos テーブル（スコープフィルタ適用後）

**集計方法**:
```python
storage_size = df_filtered.groupby('storage_location')['file_size'].sum().reset_index()
storage_size['容量_GB'] = storage_size['file_size'] / (1024**3)
```

**グラフ仕様**:
- グラフタイプ: 縦棒グラフ
- X軸: 保存場所
- Y軸: 総容量 (GB)
- 色: 保存先ごとに色分け

**Streamlit実装例**:
```python
st.subheader("💿 保存先別総容量")
st.bar_chart(storage_size.set_index('storage_location')['容量_GB'])
```

### 5.5 視聴回数の推移（折れ線グラフ、日別/週別/月別切り替え）

**目的**: 視聴活動の時系列トレンドを可視化

**データソース**: viewing_history テーブル（期間フィルタ適用後、スコープフィルタ適用後の動画のみ）

**集計粒度の切り替え**:
- 日別 (Daily): viewed_at の日付でグループ化
- 週別 (Weekly): viewed_at の週でグループ化
- 月別 (Monthly): viewed_at の月でグループ化

**UI コントロール**:
```python
granularity = st.radio(
    "集計粒度",
    options=["日別", "週別", "月別"],
    horizontal=True
)
```

**集計方法（日別の例）**:
```python
# 期間フィルタ適用後の viewing_history を取得
df_views = get_viewing_history(period_start, period_end, df_filtered['id'].tolist())

# 日別集計
df_views['date'] = pd.to_datetime(df_views['viewed_at']).dt.date
daily_trend = df_views.groupby('date').size().reset_index(name='視聴回数')
```

**グラフ仕様**:
- グラフタイプ: 折れ線グラフ
- X軸: 日付（または週、月）
- Y軸: 視聴回数
- 色: 単色

**Streamlit実装例**:
```python
st.subheader("📈 視聴回数の推移")
st.line_chart(daily_trend.set_index('date'))
```

### 5.6 視聴済み率（円グラフ）

**目的**: 視聴済み vs 未視聴の割合を可視化

**データソース**: videos テーブル（スコープフィルタ適用後）+ 累計視聴回数

**集計方法**:
```python
viewed_count = (df_filtered['total_view_count'] > 0).sum()
unviewed_count = (df_filtered['total_view_count'] == 0).sum()

pie_data = pd.DataFrame({
    'ステータス': ['視聴済み', '未視聴'],
    '動画数': [viewed_count, unviewed_count]
})
```

**グラフ仕様**:
- グラフタイプ: 円グラフ（パイチャート）
- ラベル: 視聴済み、未視聴
- 値: 動画数
- パーセント表示: あり

**Streamlit実装例**:
```python
st.subheader("🥧 視聴済み率")

# Streamlit標準には円グラフがないため、matplotlibまたはplotlyを使用
import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.pie(
    pie_data['動画数'],
    labels=pie_data['ステータス'],
    autopct='%1.1f%%',
    startangle=90,
    colors=['#1f77b4', '#ff7f0e']
)
ax.axis('equal')
st.pyplot(fig)
```

### 5.7 容量分布（ヒストグラム）

**目的**: ファイルサイズの分布を可視化

**データソース**: videos テーブル（スコープフィルタ適用後）

**集計方法**:
```python
# ファイルサイズをMB単位に変換
df_filtered['file_size_mb'] = df_filtered['file_size'] / (1024**2)

# ヒストグラム用のビン分割（例: 100MBごと）
hist_data = df_filtered['file_size_mb'].value_counts(bins=20, sort=False)
```

**グラフ仕様**:
- グラフタイプ: ヒストグラム
- X軸: ファイルサイズ (MB)
- Y軸: 動画数
- ビン数: 20（調整可能）

**Streamlit実装例**:
```python
st.subheader("📦 容量分布")
st.bar_chart(df_filtered['file_size_mb'].value_counts(bins=20, sort=False))
```

### 5.8 視聴回数分布（ヒストグラム、min/maxスライダー付き）

**目的**: 視聴回数の分布を可視化（未視聴=0を含む）

**データソース**: videos テーブル（スコープフィルタ適用後）+ 期間内視聴回数

**重要な設計方針**:
- **未視聴（0回）を含める**: 未視聴の厚みを含めて全体の偏りを一枚で理解
- **レンジ制御**: min/maxスライダーで表示範囲を調整可能（探索性を担保）

**UI コントロール**:
```python
# 視聴回数の最小値・最大値を取得
min_vc = int(df_filtered['period_view_count'].min())
max_vc = int(df_filtered['period_view_count'].max())

# スライダーでレンジ指定
view_count_range = st.slider(
    "視聴回数の表示範囲",
    min_value=min_vc,
    max_value=max_vc,
    value=(min_vc, max_vc),
    step=1
)

# レンジ内のデータをフィルタ
df_range = df_filtered[
    (df_filtered['period_view_count'] >= view_count_range[0]) &
    (df_filtered['period_view_count'] <= view_count_range[1])
]
```

**集計方法**:
```python
# 視聴回数ごとの動画数をカウント
vc_distribution = df_range['period_view_count'].value_counts().sort_index()
```

**グラフ仕様**:
- グラフタイプ: ヒストグラム（棒グラフ）
- X軸: 視聴回数（0, 1, 2, 3, ...）
- Y軸: 動画数
- 色: 単色

**Streamlit実装例**:
```python
st.subheader("📊 視聴回数分布")

# スライダー
view_count_range = st.slider(...)

# グラフ表示
st.bar_chart(vc_distribution)
```

---

## 6. ランキング仕様

### 6.1 視聴回数ランキング（Top 50）

**目的**: 最も視聴された動画を把握

**データソース**: videos テーブル + viewing_history テーブル（期間フィルタ適用後）

**集計方法**:
```python
def get_view_count_ranking(df_filtered, period_start, period_end, top_n=50):
    """
    期間内視聴回数ランキングを生成
    
    Args:
        df_filtered: スコープフィルタ適用後のDataFrame
        period_start: 期間開始日時
        period_end: 期間終了日時
        top_n: 上位N件
    
    Returns:
        ランキングDataFrame
    """
    # 期間内視聴回数を計算（viewing_history から集計）
    # ※ 実装時は JOIN or 別途クエリで取得
    
    # 降順ソート
    ranking = df_filtered.nlargest(top_n, 'period_view_count')
    
    # 順位付与
    ranking['順位'] = range(1, len(ranking) + 1)
    
    # 表示用カラム選択
    ranking = ranking[[
        '順位',
        'display_name',  # ファイル名（プレフィックス付き）
        'current_favorite_level',
        'period_view_count'
    ]].rename(columns={
        'display_name': 'ファイル名',
        'current_favorite_level': 'お気に入りレベル',
        'period_view_count': '視聴回数'
    })
    
    return ranking
```

**表示仕様**:
- 件数: Top 50件
- 表示カラム:
  - 順位（1〜50）
  - ファイル名（プレフィックス付き表示名）
  - お気に入りレベル
  - 視聴回数（期間内）
- ソート: 視聴回数降順（固定）
- 高さ: 600px（スクロール可能）

**Streamlit実装例**:
```python
st.subheader("🏆 視聴回数ランキング (Top 50)")

ranking_df = get_view_count_ranking(
    df_filtered,
    period_start,
    period_end,
    top_n=50
)

st.dataframe(
    ranking_df,
    use_container_width=True,
    height=600,
    hide_index=True
)
```

---

## 7. データ取得と集計の実装方針

### 7.1 基本アプローチ: pandas中心の集計

**理由**:
- データ規模（約2,000件）でパフォーマンス問題なし
- 多様な集計・フィルタリング・グラフ化が柔軟かつ容易
- Streamlit標準グラフとの連携が自然
- 開発効率・メンテナンス性が高い

### 7.2 データ取得の流れ

**ステップ1: 初期データ取得（効率的なSQL）**

```python
def load_analysis_data(is_deleted_filter):
    """
    分析タブ用のデータを一括取得
    
    Args:
        is_deleted_filter: 削除済みフィルタ (0 or None)
    
    Returns:
        videos データ + 累計視聴回数を結合したDataFrame
    """
    query = """
    SELECT 
        v.*,
        COALESCE(COUNT(vh.id), 0) as total_view_count,
        MAX(vh.viewed_at) as last_viewed_at
    FROM videos v
    LEFT JOIN viewing_history vh ON v.id = vh.video_id
    WHERE v.is_deleted = ?
    GROUP BY v.id
    """
    
    with get_db_connection() as conn:
        df = pd.read_sql_query(query, conn, params=[is_deleted_filter])
    
    return df
```

**ステップ2: スコープフィルタ適用（pandas）**

```python
def apply_scope_filter(df, availability_filter):
    """
    is_available フィルタを適用
    
    Args:
        df: 元DataFrame
        availability_filter: '利用可能のみ' / '利用不可のみ' / 'すべて'
    
    Returns:
        フィルタ後DataFrame
    """
    if availability_filter == '利用可能のみ':
        return df[df['is_available'] == 1]
    elif availability_filter == '利用不可のみ':
        return df[df['is_available'] == 0]
    else:  # 'すべて'
        return df
```

**ステップ3: 期間内視聴回数の計算**

```python
def calculate_period_view_count(df, period_start, period_end):
    """
    期間内視聴回数を計算してDataFrameに追加
    
    Args:
        df: 動画DataFrame
        period_start: 期間開始日時 (datetime or None)
        period_end: 期間終了日時 (datetime or None)
    
    Returns:
        period_view_count カラムを追加したDataFrame
    """
    # 期間条件に応じた viewing_history を取得
    if period_start is None and period_end is None:
        # 全期間 = total_view_count を使用
        df['period_view_count'] = df['total_view_count']
    else:
        # 期間指定あり = viewing_history から再集計
        query = """
        SELECT 
            video_id,
            COUNT(*) as period_view_count
        FROM viewing_history
        WHERE viewed_at BETWEEN ? AND ?
          AND video_id IN ({})
        GROUP BY video_id
        """.format(','.join('?' * len(df)))
        
        with get_db_connection() as conn:
            params = [period_start, period_end] + df['id'].tolist()
            df_period = pd.read_sql_query(query, conn, params=params)
        
        # 元のDataFrameにマージ（マッチしない場合は0）
        df = df.merge(df_period, left_on='id', right_on='video_id', how='left')
        df['period_view_count'] = df['period_view_count'].fillna(0).astype(int)
    
    return df
```

### 7.3 期間フィルタの変換処理

```python
def convert_period_filter(period_preset, custom_range=None):
    """
    期間フィルタのプリセットを日時範囲に変換
    
    Args:
        period_preset: '全期間' / '直近7日' / ... / 'カスタム'
        custom_range: カスタム期間の (start_date, end_date)
    
    Returns:
        (period_start, period_end) のタプル (datetime or None)
    """
    if period_preset == '全期間':
        return None, None
    elif period_preset == 'カスタム':
        if custom_range:
            start_date, end_date = custom_range
            period_start = datetime.combine(start_date, datetime.min.time())
            period_end = datetime.combine(end_date, datetime.max.time())
            return period_start, period_end
        else:
            return None, None
    else:
        # プリセット（直近N日）
        days_map = {
            '直近7日': 7,
            '直近30日': 30,
            '直近90日': 90,
            '直近180日': 180
        }
        days = days_map[period_preset]
        period_end = datetime.now()
        period_start = period_end - timedelta(days=days)
        return period_start, period_end
```

### 7.4 完全な処理フロー

```python
def render_analysis_tab():
    """分析タブのメイン処理"""
    
    st.title("📊 分析ダッシュボード")
    
    # === 1. フィルタコントロール領域 ===
    col1, col2, col3 = st.columns(3)
    
    with col1:
        availability_filter = st.selectbox(
            "利用可能性",
            options=["利用可能のみ", "利用不可のみ", "すべて"],
            index=0
        )
    
    with col2:
        include_deleted = st.checkbox("削除済みを含む", value=False)
    
    with col3:
        period_preset = st.selectbox(
            "期間",
            options=["全期間", "直近7日", "直近30日", "直近90日", "直近180日", "カスタム"],
            index=0
        )
    
    # カスタム期間選択
    custom_range = None
    if period_preset == "カスタム":
        custom_range = st.date_input(
            "期間を指定",
            value=(datetime.now() - timedelta(days=30), datetime.now()),
            max_value=datetime.now()
        )
    
    # === 2. データ取得と加工 ===
    is_deleted_filter = None if include_deleted else 0
    df = load_analysis_data(is_deleted_filter)
    
    # スコープフィルタ適用
    df_filtered = apply_scope_filter(df, availability_filter)
    
    # 期間フィルタ変換
    period_start, period_end = convert_period_filter(period_preset, custom_range)
    
    # 期間内視聴回数を計算
    df_filtered = calculate_period_view_count(df_filtered, period_start, period_end)
    
    # === 3. KPIサマリー領域 ===
    col1, col2, col3, col4, col5 = st.columns(5)
    
    total_videos = len(df_filtered)
    total_size_gb = df_filtered['file_size'].sum() / (1024**3)
    viewed_videos = (df_filtered['total_view_count'] > 0).sum()
    unviewed_videos = (df_filtered['total_view_count'] == 0).sum()
    period_view_count = df_filtered['period_view_count'].sum()
    
    with col1:
        st.metric("総動画数", f"{total_videos:,}本")
    with col2:
        st.metric("総容量", f"{total_size_gb:.2f} GB")
    with col3:
        st.metric("視聴済み", f"{viewed_videos:,}本")
    with col4:
        st.metric("未視聴", f"{unviewed_videos:,}本")
    with col5:
        st.metric("期間内総視聴回数", f"{period_view_count:,}回")
    
    # === 4. グラフ領域 ===
    # (各グラフの実装は 5章 を参照)
    render_level_charts(df_filtered)
    render_storage_charts(df_filtered)
    render_trend_chart(df_filtered, period_start, period_end)
    render_viewed_pie_chart(df_filtered)
    render_size_distribution(df_filtered)
    render_view_count_distribution(df_filtered)
    
    # === 5. ランキング領域 ===
    render_ranking(df_filtered, period_start, period_end)
```

---

## 8. エッジケースとエラーハンドリング

### 8.1 データが存在しない場合

**ケース**: フィルタ条件に合致する動画が0件

**対応**:
```python
if len(df_filtered) == 0:
    st.warning("⚠️ 条件に合致する動画が見つかりませんでした。フィルタ条件を変更してください。")
    st.stop()
```

### 8.2 期間内視聴履歴が0件の場合

**ケース**: 指定期間内に視聴イベントが1件もない

**対応**:
- グラフは空のまま表示（エラーにしない）
- 「期間内総視聴回数」は 0 回と表示
- 視聴回数の推移グラフは「データがありません」と表示

```python
if df_views.empty:
    st.info("ℹ️ 指定期間内の視聴履歴がありません。")
else:
    st.line_chart(daily_trend.set_index('date'))
```

### 8.3 カスタム期間の不正入力

**ケース**: 開始日 > 終了日

**対応**:
```python
if custom_range and custom_range[0] > custom_range[1]:
    st.error("❌ 開始日は終了日より前に設定してください。")
    st.stop()
```

### 8.4 削除済みのみを表示した場合

**ケース**: `include_deleted=True` かつ `is_deleted=1` のみが対象

**対応**:
- 通常通り集計・表示（エラーにしない）
- 削除済みのみのフィルタは技術的に可能だが、UI上は提供しない（is_deleted=0 or 全含む のみ）

---

## 9. パフォーマンス考慮事項

### 9.1 想定データ規模とパフォーマンス

**前提**:
- 動画数: 約2,000件
- 視聴履歴: 仮に1動画あたり平均10回 = 約20,000レコード

**pandas処理時間の見積もり**:
- データ読み込み: < 100ms
- フィルタリング: < 10ms
- 集計・グループ化: < 50ms
- グラフ描画: < 100ms

**合計**: 1秒以内で完結（問題なし）

### 9.2 最適化の余地

**将来的にデータが増加した場合（5,000件以上）の対策**:

1. **SQLでの事前集計を強化**
   - レベル別・保存先別集計をSQL側で実施
   - pandasに渡すデータ量を削減

2. **キャッシング活用**
   - Streamlit `@st.cache_data` デコレータで集計結果をキャッシュ
   - フィルタ変更時のみ再計算

```python
@st.cache_data(ttl=600)  # 10分間キャッシュ
def load_analysis_data(is_deleted_filter):
    # データ取得処理
    pass
```

3. **インデックス最適化**
   - `viewing_history.viewed_at` にインデックス追加
   - `videos.is_available`, `videos.is_deleted` にインデックス追加

---

## 10. 将来の拡張可能性

### 10.1 フェーズ2で検討する機能

**気分タグ分析**
- 気分タグごとの視聴回数
- 気分タグの時系列トレンド

**高度な統計分析**
- 視聴回数の統計量（平均、中央値、標準偏差）
- 外れ値検出（極端に視聴回数が多い/少ない動画）

**登場人物分析**（現時点では不要だが将来的に）
- 登場人物別の視聴傾向
- 登場人物別のお気に入りレベル分布

**エクスポート機能**
- CSVダウンロード
- Markdownレポート生成

### 10.2 技術的拡張

**可視化の強化**
- plotly/altairへの移行（インタラクティブ性向上）
- ダッシュボードのレイアウトカスタマイズ

**リアルタイム更新**
- 視聴履歴の自動反映
- データベース変更の検知と再描画

---

## 11. まとめ

本設計書では、動画管理システムの分析タブを以下の方針で定義した：

1. **読み取り専用ダッシュボード**として、ライブラリの状態を統計的に把握
2. **利用可能のみを既定スコープ**とし、スコープ・期間を動的に切り替え可能
3. **期間フィルタは視聴回数系指標に完全連動**、未視聴は生涯未視聴として固定
4. **pandas中心の集計**で柔軟性と開発効率を優先
5. **シンプルで一貫性のある設計**により、ユーザーが迷わず理解できる

この設計により、ユーザーは自身の動画ライブラリの全体像を素早く把握し、視聴傾向を分析し、効果的な動画管理の判断材料を得ることができる。

---

**変更履歴**

| バージョン | 日付 | 変更内容 |
|----------|------|---------|
| 1.0 | 2026-01-11 | 初版作成 |
