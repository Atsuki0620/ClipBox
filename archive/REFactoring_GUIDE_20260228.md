# ClipBox リファクタリングガイド

**作成日**: 2026-02-28  
**対象リポジトリ**: Atsuki0620/ClipBox  
**前提**: 個人利用・ローカルDB・外部プレイヤー起動・Windows環境

---

## 0. 目的とスコープ

### このドキュメントの目的

- **「壊さず改善する」**: 既存機能を維持しながら、コードの信頼性・保守性を段階的に高める
- **「将来移行の土台を作る」**: Streamlit → Flask/FastAPI 移行時の再利用率を最大化する設計を整備する
- **「迷わず進める」**: 各テーマに「何をすれば終わりか」を明示し、作業の立ち止まりを防ぐ

### 対象外

- 新規機能追加（気分タグ、ML推薦、サムネイル等）の詳細UI設計
- Flask/FastAPIへの実際の移行作業
- クラウドストレージ対応
- 動画の編集・変換機能

### 前提条件（変えない）

- 個人利用・ローカル完結（ネットワーク送信なし）
- SQLite（`data/videos.db`）をデータストアとして使用
- 外部プレイヤー（GOMなど）を `subprocess.Popen` で起動
- Windows環境、日本語パスを含むファイル操作
- 既存の3層アーキテクチャ（UI層 → Core層 → Data層）の方向性を維持
- Core層は `streamlit` に依存しない（Flask移行時の再利用性確保）

---

## 1. 優先度と進め方（ロードマップ）

### 基本方針：「安全装置 → 構造整理 → 価値増強」

```
Phase A（安全装置）     Phase B（構造整理）     Phase C（価値増強）
─────────────────       ─────────────────       ─────────────────
テスト基盤の整備    →   層の分離強化        →   ロギング整備
信頼性・整合性確保      責務の明確化            依存関係の固定
                                                セキュリティ確認
```

### 6テーマの優先順位と狙い

| 優先度 | テーマ | 狙い | 短期ゴール |
|--------|--------|------|-----------|
| 1 | **信頼性・整合性** | データ破損リスクをゼロに近づける | 判定操作（リネーム＋DB更新）で不整合が起きない |
| 2 | **層の分離と責務の整理** | 将来の移行コストを下げる | UIがDBを直接触らない、Core層がstをimportしない |
| 3 | **品質保証・テスト戦略** | リファクタリング中に「壊れてない」を確認できる | ローカルで`pytest`が通り主要ユースケースがカバーされる |
| 4 | **可観測性（ロギング）** | 問題発生時に何が起きたか追跡できる | 判定・スキャン・バックアップの結果をログ1行で追える |
| 5 | **依存関係・パッケージ管理** | 環境の再現性を保証する | 新PC/新環境で手順書通りに動く |
| 6 | **セキュリティ・プライバシー** | 意図せぬ情報漏洩・危険な挙動を防ぐ | フルパスがログ・UIに露出しない、想定外入力でクラッシュしない |

### 最初の5手（推奨順）

1. **テスト基盤を整える** — `conftest.py` の `tmp_db` フィクスチャを全テストに適用し、本番DB破壊リスクを排除
2. **整合性の定義を書く** — 「判定操作の成功状態・失敗状態」を文書化し、テストケースとして表現する
3. **責務の境界を確定する** — UI層がDBを直接触っている箇所を全て洗い出し、Core層のメソッドに委譲する
4. **ログの骨格を入れる** — 判定・スキャン・バックアップの3操作だけにログを追加する
5. **依存関係を固定する** — `requirements.txt` にバージョン上限を追加し `pip freeze` で確認する

---

## 2. 信頼性・整合性（最優先）

### 2.1 ゴール（何ができればOKか）

- 判定操作（お気に入りレベル変更）において、「ファイルリネーム成功かつDB更新失敗」「DB更新成功かつファイルリネーム失敗」という中間状態が残らない
- 操作失敗時に「安全な状態」（変更前と同等）へ戻るか、失敗であることがUI上で明示される
- スキャン操作が外付けHDD未接続時に、接続済みドライブのレコードを `is_available=0` に誤って変更しない
- 同一操作を2回実行しても、データが2重に記録されたり矛盾した状態にならない（冪等性の確保）

### 2.2 方針（どう進めるか）

#### 原子性：ファイル操作とDB更新の境界

- ファイルリネームとDBの `UPDATE` は「両方成功」または「両方無効」のみを許容する
- 現実的な制約として、ファイルシステムとDBを完全な1トランザクションにすることはできないため、以下の手順で疑似的な原子性を確保する
  - Step 1: ファイルが存在することを確認する
  - Step 2: ファイルリネームを実行する
  - Step 3: リネーム成功時のみ、DBをコミットする
  - Step 4: DBコミット失敗時は、ファイルを元の名前に戻す（ロールバック試行）
- ファイルロールバックが失敗した場合は「ファイルとDBが不一致」の状態を記録し、ユーザーに手動修正を促す

#### 失敗時の振る舞い

- 例外は「ファイル系（FileNotFoundError, PermissionError）」と「DB系（sqlite3.Error）」に分類する
- どちらの失敗も、ユーザーには「失敗した操作」「現在のファイル名」「推奨される対処法」を返す
- 内部例外の詳細（スタックトレース）はログにのみ記録し、UIには出力しない

#### 冪等性

- `FileScanner.scan_and_update()` は何度実行しても最終的なDB状態が同じになることを確認する
  - ファイルが存在すれば `is_available=1`、スキャン対象ディレクトリ内で見つからなければ `is_available=0`
  - スキャン対象外ディレクトリのレコードは変更しない（現行実装の `scanned_dirs` フィルタを維持）
- `insert_play_history` は冪等でないが、呼び出し箇所（`play_video`）を1か所に集約することで二重呼び出しを防ぐ
- `init_database()` は `CREATE TABLE IF NOT EXISTS` / `ALTER TABLE ADD COLUMN（存在チェック付き）` で何度でも安全に呼び出せる状態を維持する

#### DBトランザクション境界

- 1回の「判定操作」（リネーム＋DB更新＋判定履歴記録）を1つのDBトランザクションとして扱う
- `viewing_history` と `play_history` の挿入は同一トランザクション内で行う（現行実装済み：`conn` 引数渡し方式を維持）
- `auto_start_counters` は必ず外側の接続（`conn`）を受け取って実行し、ネスト接続によるロック競合を避ける（現行実装済み）

### 2.3 チェックリスト（レビュー観点）

新しいコードや変更をレビューする際は以下を確認する。

**データ破壊リスク確認**
- [ ] ファイルリネームとDB更新が同一トランザクション内、または疑似原子性手順で実行されているか
- [ ] ファイル操作失敗時にDBがコミットされていないか
- [ ] DB操作失敗時にファイルが変更されたままになっていないか
- [ ] スキャン処理が「スキャンしていないドライブのレコード」を変更していないか

**不整合の代表例（特に注意する箇所）**

| フィールド | 不整合パターン | 結果 |
|-----------|--------------|------|
| `is_judging` | 判定開始後に例外で終了 → フラグが `1` のまま | 動画に「判定中」バッジが永続表示される |
| `current_full_path` | リネーム後にDBが更新されない | 再生時にファイルが見つからなくなる |
| `current_favorite_level` | ファイルリネームとDB更新が別トランザクション | ファイル名とDBのレベルが食い違う |
| `viewing_history` / `play_history` | 片方だけ記録される | 視聴回数とカウンターに乖離が生じる |
| `needs_selection` | スキャン後に `is_available` の更新ロジックが誤って適用 | 未選別フラグが消える |
| `is_available` | 外付けHDD未接続時に全件 `0` になる | HDD上の全動画が「利用不可」と誤表示される |

---

## 3. 層の分離と責務の整理

### 3.1 ゴール

- UI層（`streamlit_app.py`、`ui/*.py`）は「表示・入力・コールバック受け渡し」のみを担う
- Core層（`core/*.py`）がすべてのビジネスロジックとDB操作を担う
- Core層内でも「VideoManagerが何でも屋にならない」よう、責務が明確な場所に処理が置かれている
- `core/` ディレクトリのどのファイルも `import streamlit` を含まない

### 3.2 方針（どう進めるか）

#### `VideoManager` の肥大化を抑える方針

- `VideoManager` はフィルタリング・再生・判定・視聴履歴記録のみを担当する
- データ集計（ランキング、期間フィルタ、いいね集計）は `analysis_service.py` が担当する（現行分離済み）
- セレクション固有のロジックは `selection_service.py` が担当する（現行分離済み）
- 今後新しいビジネスロジックを追加する場合、`VideoManager` に追加するのではなく専用サービスファイルを作成することを優先する

#### DBアクセスの集約方針

- SQL文は `core/database.py`（ヘルパー関数）または各サービス層（`video_manager.py`、`analysis_service.py` 等）に書く
- UI層（`ui/*.py`）から `get_db_connection()` を直接呼び出すことを禁止する
- 新機能を追加する場合は、UI層から呼び出せるサービス関数を Core層に用意してから UI を実装する

#### 返却値・エラー表現の統一方針

- 操作結果は `{'status': 'success'|'error', 'message': str}` 形式のdictで返す（現行パターンを維持・統一する）
- リスト返却のクエリ関数は「空リスト」を返し、`None` を返さない
- 例外は Core層内で捕捉し、上記の dict 形式に変換してから UI に返す（UI層でtry-catchしない）

#### 「Core層で `st` を import しない」の遵守

- `core/` 配下のすべてのファイルで `import streamlit` が存在しないことを確認する
- `@st.cache_data` デコレータを持つ関数は `ui/cache.py` に置く（現行実装済み）
- CI・自動チェックがない場合は、コミット前の手動確認チェックリストに追加する

#### 後方互換 shim ファイルの取り扱い

- `core/config_store.py`、`core/history_repository.py`、`core/file_ops.py` は現状 re-export のみ
- 新規 import はこれらを経由せず、直接 `core/config_utils.py` 等を参照する
- 既存の import を破壊的に変更するメリットが少ないため、削除は Flask 移行タイミングまで保留する

### 3.3 完了条件

- [ ] `grep -r "import streamlit" core/` がゼロ件
- [ ] `grep -r "get_db_connection" ui/` がゼロ件（`ui/cache.py` を除く）
- [ ] ファイルリネーム・DB更新・判定履歴挿入が `core/video_manager.py` の `set_favorite_level_with_rename()` に集約されている
- [ ] 新しいビジネスロジックが `streamlit_app.py` または `ui/` ファイルに直接書かれていない

---

## 4. 品質保証・テスト戦略

### 4.1 目的（平易に）

「リファクタリングしても壊れてないと確信できる」状態を作る。テストが通れば、変更前と同じ振る舞いをしていると信頼できる。

### 4.2 テストの優先順位

**最初に守るべき10ユースケース（事故が起きると困る順）**

| 優先度 | ユースケース | テストファイル案 |
|--------|------------|----------------|
| 1 | プレフィックス解析（全パターン）| `test_scanner.py`（既存） |
| 2 | 判定成功時のリネーム＋DB更新＋履歴記録 | `test_video_manager.py`（既存） |
| 3 | 判定失敗時（ファイル不在・権限なし）のDB非更新 | `test_video_manager.py` |
| 4 | スキャン時の `is_available` 更新（接続済みディレクトリのみ） | `test_scanner.py` |
| 5 | 外付けHDD未接続時にHDDレコードが `is_available=0` にならない | `test_scanner.py` |
| 6 | バックアップ生成（出力先にファイルが作られる） | `test_backup.py`（新規） |
| 7 | `viewing_history` と `play_history` の同一トランザクション記録 | `test_video_manager.py` |
| 8 | `is_judging` フラグの開始・完了・失敗時の状態 | `test_video_manager.py` |
| 9 | 期間フィルタ（全期間・直近30日・カスタム）の境界値 | `test_analysis_service.py`（既存） |
| 10 | `extract_essential_filename` の `!`/`+` プレフィックス処理 | `test_scanner.py`（既存） |

**テスト種別の方針**

- ユニットテスト優先：副作用を持つ関数は引数でモック可能にし、入出力だけをテストする
- 統合テストは「テンポラリDB + テンポラリディレクトリ」を使い、本番データに触れない
- UIテスト（Streamlitのレンダリング）は対象外とする（工数に見合わない）

### 4.3 テスト容易性のための設計方針

#### 副作用を差し替え可能にする

- `subprocess.Popen`（プレイヤー起動）はテスト時にモックする。`play_video()` の「プレイヤー起動部分」を関数として分離し、依存注入できる形にする
- ファイルI/O（リネーム）はテスト用の `tmp_path` （pytestの組み込みフィクスチャ）でテンポラリディレクトリを使う
- DBアクセスは `conftest.py` の `tmp_db` フィクスチャで本番DBと完全に切り離す（現行実装済み）

#### テストデータの考え方

- テンポラリDB：`conftest.py` の `tmp_db` フィクスチャを全テストで利用する
- テンポラリディレクトリ：pytestの `tmp_path` フィクスチャでリネーム対象ファイルを作成する
- 実際の動画ファイルは使用しない（ダミーファイルで十分）

#### 何をモックし、何を実物で検証するか

| 対象 | 方針 |
|------|------|
| SQLite操作 | 実物のDBを使う（ただしテンポラリDB） |
| ファイルリネーム | 実物のファイルを使う（ただしテンポラリディレクトリ） |
| `subprocess.Popen` | モックする（プレイヤー起動は確認できないため） |
| `datetime.now()` | 重要なタイムスタンプ検証時のみモックする |
| ネットワーク | 使用しないため対象外 |

### 4.4 完了条件

- [ ] `pytest` をローカルで実行し、全テストがグリーン（1件も失敗しない）
- [ ] 上記10ユースケースすべてがテストケースとして存在する
- [ ] テスト実行時に本番の `data/videos.db` が書き換えられていない（`tmp_db` フィクスチャが機能している）
- [ ] リファクタリング前後で同じテストスイートが同じ結果を返す

---

## 5. 可観測性（ロギング）

### 5.1 方針（最小でよい）

**ログを残す操作（この3つだけ）**

Pythonの標準 `logging` モジュールを使用する。`print()` によるデバッグ出力は本番コードから除去する。

| 操作 | ログレベル | 記録する情報 |
|------|-----------|-------------|
| スキャン開始・終了 | INFO | ルートディレクトリ数、スキャン済みファイル数、新規追加数、`is_available` 変更数、所要時間 |
| 判定実行 | INFO（成功）/ WARNING（失敗） | 動画ID、旧レベル→新レベル、リネーム結果（success/failure）、所要時間(ms)、ストレージ種別 |
| DBバックアップ | INFO（成功）/ ERROR（失敗） | バックアップ先ファイル名（パスは短縮）、結果、ファイルサイズ |

**ログフォーマット（機械可読・簡素）**

```
YYYY-MM-DDTHH:MM:SS [LEVEL] operation=<name> key=value key=value ...
```

例：
```
2026-02-28T15:30:00 [INFO] operation=scan dirs=2 found=1850 added=12 unavailable=3 elapsed_ms=1250
2026-02-28T15:31:05 [INFO] operation=judgment video_id=42 old_level=2 new_level=3 rename=success elapsed_ms=18 storage=C_DRIVE
2026-02-28T15:31:05 [WARNING] operation=judgment video_id=88 old_level=-1 new_level=2 rename=failure reason=permission_error
```

**ログ出力先**

- コンソール出力とファイル出力の両方を用意する
- ファイル出力先は `data/clipbox.log`（`.gitignore` に追加する）
- ファイルサイズ上限を設け、ローテーション（`RotatingFileHandler`）を設定する

### 5.2 プライバシー配慮（必須）

- フルパス（`C:\Users\atsuki\...`）はログに出力しない
- パスをログに記録する場合は「ファイル名のみ」または「ルートからの相対パス」に短縮する
  - 例：`C:\Users\atsuki\OneDrive\data\###_作品名.mp4` → `###_作品名.mp4`
- エラーメッセージにフルパスが含まれる場合も同様に短縮してからログに記録する
- `essential_filename` はログに含めてよい（ファイル名はシステム上の識別情報であり個人情報に相当しない）

### 5.3 完了条件

- [ ] `print()` による出力が Core層（`core/*.py`）から除去されている
- [ ] 判定・スキャン・バックアップの3操作のログが `data/clipbox.log` に記録される
- [ ] ログ1行を見て「何の操作が・いつ・どんな結果だったか」が判断できる
- [ ] ログファイルをスクリーンショットで共有しても、フルパスが露出しない

---

## 6. 依存関係・パッケージ管理

### 6.1 方針

#### Pythonバージョンの固定

- `python_requires` の指定、または `README.md` への明示で Python 3.10 以上を要件とする
- `.python-version` ファイルをリポジトリに追加してバージョンを明示する（pyenvが使える場合）

#### パッケージバージョンの固定戦略

- `requirements.txt` に上限付きバージョン指定を追加する（例：`streamlit>=1.30.0,<2.0.0`）
- 厳密固定（`==` による pinning）は使わない（セキュリティ更新の適用を妨げるため）
- `pip freeze > requirements-lock.txt` で再現用のロック済みリストも保管する（gitignoreしない）

#### 依存の棚卸し

| カテゴリ | 現状 | 対応方針 |
|---------|------|---------|
| 使用中・必須 | `streamlit`, `pandas`, `plotly`, `matplotlib`, `seaborn`, `japanize-matplotlib`, `pytest`, `pytest-cov` | 残す |
| コメントアウト済み・将来用 | `watchdog`, `opencv-python`, `flask`, `fastapi`, `uvicorn` | コメントのままでよい（意図的に除外中であることがわかるため） |
| 要確認 | `seaborn`（現在の使用箇所を確認） | 使用箇所がなければ削除を検討 |

### 6.2 完了条件

- [ ] `requirements.txt` にバージョン上限が設定されている
- [ ] `README.md` または `docs/` に「環境構築手順」が記載されており、手順通りに実行すれば `pytest` が通る
- [ ] 新PCで `git clone` → `python -m venv venv` → `pip install -r requirements.txt` → `pytest` が成功する
- [ ] `requirements-lock.txt` がリポジトリに存在し、再現可能な状態が記録されている

---

## 7. セキュリティ・プライバシー（最低限）

### 7.1 方針（ローカル個人利用前提）

#### DB・バックアップの置き場所・扱い

- `data/videos.db` および `data/backups/` は `.gitignore` で管理されている（現行実装済み）
- バックアップファイルは自動削除されないため、定期的な手動削除または上限件数による自動削除を実装することを推奨する（実装優先度は低）
- `data/snapshots/` も同様に個人データを含むため `.gitignore` 対象を維持する

#### ログ・UIに表示する情報の方針

- フルパス（ユーザー名を含む）はUIに表示しない場合が理想だが、利便性のため表示は許容する
- ログへのフルパス出力は禁止する（Section 5 参照）
- スクリーンショットをGitHub Issueなどに添付する場合、フルパスが含まれていないか確認する（自動化は困難なため、AGENTS.md のガイドラインで案内する）

#### 外部プレイヤー起動の入力検証

- `play_video()` でファイルパスを渡す前に `Path.exists()` によるファイル存在確認を行う（現行実装済み）
- 存在確認済みのパスのみ `subprocess.Popen` に渡す
- `shell=True` を使用しているため、パスに意図しない文字（セミコロン、アンパサンド等）が含まれる場合のリスクを把握する
  - 個人利用かつ自分で管理するファイルが対象のため、現時点では「確認済みパスのみ渡す」で十分
  - 将来的に複数ユーザー対応する場合はシェルインジェクション対策が必要

#### SQLインジェクション対策（確認）

- すべてのSQLクエリがプレースホルダ（`?`）を使用していることを確認する（現行実装済み）
- f-string や文字列結合でSQL文を組み立てている箇所がないことを定期的に確認する

### 7.2 完了条件

- [ ] `data/*.db` および `data/backups/`、`data/snapshots/` が `.gitignore` に記載されている（現行済み）
- [ ] `subprocess.Popen` に渡すパスが必ず `Path.exists()` 後の値である
- [ ] `grep -r "f\"" core/*.py | grep "execute"` で f-string を使ったSQL文がゼロ件
- [ ] ログファイルにフルパスが含まれていないことを手動で確認できる

---

## 8. 作業テンプレート（実務で使う）

### 8.1 PRの粒度指針

**原則：1PRは1つの意図を持つ**

| PR規模 | 目安 | 例 |
|--------|------|-----|
| 小（推奨） | 変更ファイル5件以内、差分200行以内 | `conftest.py` のフィクスチャ整備のみ |
| 中 | 変更ファイル10件以内、差分500行以内 | 特定サービス層の責務整理 |
| 大（要分割） | それ以上 | リファクタリング全体を一度にやろうとしている → 分割する |

**PRに含めてはいけないもの**
- リファクタリングと機能追加の混在
- 動作確認していないコード
- `data/videos.db`、`data/user_config.json` などの個人データファイル

### 8.2 変更前後で見る観点（チェックリスト）

コードを変更したら提出前に以下を確認する。

**必須確認（全PR）**
- [ ] `python -m py_compile streamlit_app.py core/*.py` がエラーなし
- [ ] `pytest` が全件グリーン
- [ ] `grep -rn "import streamlit" core/` がゼロ件
- [ ] `grep -rn "get_db_connection" ui/` がゼロ件（`ui/cache.py` を除く）

**データ変更を伴うPR**
- [ ] `is_available`、`current_favorite_level`、`current_full_path` の変更タイミングが意図通りか
- [ ] トランザクション境界が明確か（途中でコミットされていないか）
- [ ] テンポラリDBを使ったテストケースが追加されているか

**UI変更を伴うPR**
- [ ] 既存のランダム再生・ライブラリ・セレクション・分析タブが正常動作するか（手動確認）
- [ ] `st.rerun(scope="fragment")` の呼び出しがタブ切り替えを引き起こさないか

### 8.3 Doneの定義

以下をすべて満たした時点でタスク完了とする。

1. **テスト通過**: `pytest` が全件グリーン
2. **手動確認**: 変更に関連する操作（判定・スキャン・再生・表示など）を実際のアプリで確認済み
3. **ログ確認**: 変更対象の操作がログに期待通り記録される（ロギング対象の場合）
4. **ドキュメント更新**: 機能やDB構造が変わった場合は `CLAUDE.md` または `docs/` の該当ファイルを更新済み
5. **レビュー観点チェック**: Section 8.2 のチェックリストが全件✅

---

## 付録：残存する技術的負債（未対応）

以下は `docs/CODE_REVIEW_20260224.md` に記録された未対応項目のうち、将来対応を検討する事項。対応優先度は低いが、認識として共有する。

| ID | 概要 | 対応タイミング |
|----|------|--------------|
| A-2 | 同名ファイルが異なるフォルダに存在する場合のサイレント上書き | 実際に問題が発生した時点 |
| A-4 | `likes` テーブルへの無制限追記（連打対策なし） | いいね機能を本格活用する時点 |
| A-5 | `migration_history.txt` ベースのマイグレーション管理 | マイグレーション件数が増えた時点 |
| A-8 | Windows `atime` 更新無効化環境でのファイルアクセス検知機能不全 | 検知機能を再有効化する時点 |
| B-1 | 全件取得後のPython側スライス（3,000件以上で劣化予定） | 動画数が3,000件を超えた時点 |
| B-3 | `snapshot.py` の非原子的な書き込みによる不完全スナップショット | スナップショット機能を多用する時点 |
| C-3 | 後方互換 shim ファイルの乱立（`config_store.py` 等） | Flask移行時 |
| C-7 | `Video` データクラスのフラグフィールド肥大化 | フラグが5個を超えた時点 |

---

**変更履歴**

| バージョン | 日付 | 変更内容 |
|----------|------|---------|
| 1.0 | 2026-02-28 | 初版作成（CODE_REVIEW_20260224.md の解決済み・未解決を踏まえて作成） |
| 1.1 | 2026-02-28 | Phase 1〜3 実装完了 |
| 1.2 | 2026-02-28 | バグ修正2件（未判定ランダム・セレクション is_available 問題） |

---

## 9. 実装進捗ログ

| 日付 | フェーズ | 主な変更 | テスト結果 |
|------|---------|---------|-----------|
| 2026-02-28 | Phase 1: テスト補強 | test_video_manager.py +2件, test_scanner.py +2件, test_backup.py 新規, create_backup()追加 | 27件/27件 |
| 2026-02-28 | Phase 2: ロギング | core/logger.py 新規, print()除去4箇所, 判定・スキャン・バックアップログ追加, .gitignore更新 | 27件/27件 |
| 2026-02-28 | Phase 3: 依存関係+仕上げ | requirements.txt上限追加, requirements-lock.txt生成, run_startup_migration()追加, streamlit_app.py委譲 | 27件/27件 |
| 2026-02-28 | Bug Fix 1: 未判定ランダム表示なし | get_unrated_random_videos() に LIMIT + Path.exists() フィルタ追加 → LIMIT 廃止・ドライブ単位キャッシュ方式に変更 | 28件/28件 |
| 2026-02-28 | Bug Fix 2: セレクション全件利用不可 | scanner.py の startswith バグ修正 + scan_files() にセレクションフォルダスキャン統合 | 29件/29件 |

### チェックリスト（完了状況）

#### 信頼性・整合性 (Priority 1)
- [x] is_judging フラグの開始・完了テスト追加
- [x] ファイル不在時DBが変更されないテスト追加
- [x] is_available 保護（ディレクトリ限定）テスト追加
- [x] バックアップ生成テスト追加

#### 品質保証・テスト戦略 (Priority 3)
- [x] pytest 全件グリーン（29件）

#### 可観測性・ロギング (Priority 4)
- [x] core/ の print() をゼロ件に
- [x] 判定・スキャン・バックアップのログを data/clipbox.log に記録

#### 依存関係・パッケージ管理 (Priority 5)
- [x] requirements.txt にバージョン上限を設定
- [x] requirements-lock.txt をリポジトリに追加

#### 層の分離と責務の整理 (Priority 2)
- [x] streamlit_app.py の直接DB接続（マイグレーション）を app_service に委譲

---

## 10. バグ修正記録

### Bug Fix 1: 未判定ランダムタブで動画が表示されない

**発生日**: 2026-02-28

**症状**
未判定ランダムタブを開いても動画が1件も表示されない。DBには未判定（`current_favorite_level=-1`）の動画が798件存在する。

**原因**
2段階の複合バグ。

1. **直接原因（統計的サンプリング問題）**
   `get_unrated_random_videos()` が `LIMIT n*3`（デフォルト30件）でランダムサンプリングしてから `Path.exists()` でフィルタしていた。
   DBの実態：未判定798件のうち C_DRIVE が9件・EXTERNAL_HDD（D: 未接続）が789件。
   30件中に C_DRIVE が1件も入らない確率 ≈ **72%** となり、高確率で空になっていた。

2. **根本原因（A-1 修正との組み合わせ）**
   A-1 修正（外付けHDD未接続時に HDD レコードを `is_available=0` にしない）により、D: 未接続でも D: レコードが `is_available=1` のまま残る。
   `get_unrated_random_videos()` は `is_available=1` かつ `current_favorite_level=-1` で取得するため、D: の789件が常にプールに混入していた。

**修正内容**（`core/video_manager.py`）
- SQLクエリから `LIMIT` を撤廃し、全件を `ORDER BY RANDOM()` で取得
- ドライブ単位の接続確認（`Path("D:/").exists()`）を1回だけ実行してキャッシュ
- 未接続ドライブのファイルは個別 `Path.exists()` を呼ばずスキップ
- `n` 件集まった時点でループを終了

**最終状態**
- D: 未接続時：C_DRIVE の9件が確実に取得される
- D: 接続時：C_DRIVE + D_DRIVE から最大 n 件取得
- テスト追加：`test_get_unrated_random_videos_excludes_nonexistent_files`（29件/29件）

---

### Bug Fix 2: セレクションタブの動画がすべて「利用不可」表示

**発生日**: 2026-02-28

**症状**
セレクションタブを開くと、物理的に存在するファイルも含めてすべての動画が「利用不可（×）」と表示される。DBの `data_selection` 配下103件が全て `is_available=0` になっていた。

**原因**
2段階の複合バグ。

1. **直接原因（パス文字列比較バグ）**
   `scanner.py` の `scan_and_update()` が「スキャン対象ディレクトリ配下かどうか」を文字列の `startswith` で判定していた。
   - スキャン対象：`C:\...\ドキュメント\data`
   - セレクションフォルダ：`C:\...\ドキュメント\data_selection\...`
   - `"data_selection\...".startswith("data")` → **True**（誤）

   結果：ライブラリスキャン時に `data` を走査しても `data_selection` 内のファイルは見つからないため、毎回 `is_available=0` に更新されていた。

2. **設計上の抜け（セレクションフォルダ未統合）**
   サイドバーの「📁 ファイルをスキャン」は `library_roots` しかスキャンせず、`selection_folder` を無視していた。
   そのため `scan_selection_folder()` を単独で実行しない限り、セレクションフォルダの `is_available` が修復されなかった。

**修正内容**

| ファイル | 変更 |
|---------|------|
| `core/scanner.py` L161 | `startswith` → `Path.is_relative_to()` に変更（パス境界を正しく識別） |
| `streamlit_app.py` `scan_files()` | ライブラリスキャン後に `scan_selection_folder()` を追加呼び出し |
| `streamlit_app.py` `scan_files_for_settings()` | 同上 |
| `tests/test_scanner.py` | `test_scan_does_not_falsely_mark_sibling_dir_unavailable` 追加 |

**最終状態**
- `data_selection` 内の107件が `is_available=1` に修復（1件は物理ファイル不在のため `is_available=0` のまま、正常）
- 「📁 ファイルをスキャン」1回でライブラリ + セレクションフォルダが同時に更新される
- 設定タブの「🔍 セレクションフォルダをスキャン」は引き続き有効（セレクションのみ軽量スキャンしたい場合に使用）
- テスト：29件/29件
