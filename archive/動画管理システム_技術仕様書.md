# 動画管理システム 技術仕様書

作成日: 2026年1月1日  
バージョン: 1.0

---

## 1. システムアーキテクチャ

### 1.1 全体構成

```
┌─────────────────────────────────────────┐
│          UI Layer (Streamlit)           │
│  - フィルタUI                            │
│  - 動画一覧表示                          │
│  - 再生ボタン                            │
│  - 統計ダッシュボード                    │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│       Core Layer (ビジネスロジック)      │
│  - video_manager.py                     │
│    - フィルタリング                      │
│    - ランダム選択                        │
│    - 再生処理                            │
│    - 視聴履歴記録                        │
│  - scanner.py                           │
│    - ファイルスキャン                    │
│    - ファイル識別                        │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│      Data Layer (データアクセス)         │
│  - database.py                          │
│    - CRUD操作                           │
│    - トランザクション管理                │
│  - models.py                            │
│    - データ構造定義                      │
└────────────┬────────────────────────────┘
             │
┌────────────▼────────────────────────────┐
│         SQLite Database                 │
│  - videos.db                            │
└─────────────────────────────────────────┘
```

### 1.2 レイヤー分離の方針

**UI層**: Streamlit固有のコード（Flask移行時は削除）
- `streamlit_app.py`
- UIコンポーネントの配置とイベント処理のみ

**コア層**: ビジネスロジック（Flask移行時も再利用）
- `core/video_manager.py`: 動画管理の主要ロジック
- `core/scanner.py`: ファイルスキャンとファイル識別
- `core/models.py`: データ構造とバリデーション

**データ層**: データベースアクセス（Flask移行時も再利用）
- `core/database.py`: SQLiteへのCRUD操作
- スキーマ定義、マイグレーション管理

---

## 2. データベース設計

### 2.1 テーブル定義

#### 2.1.1 videos テーブル

動画ファイルの基本情報を管理する。

```sql
CREATE TABLE videos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    essential_filename TEXT NOT NULL UNIQUE,  -- プレフィックス除去後のファイル名（識別用）
    current_full_path TEXT NOT NULL,          -- 現在のフルパス
    current_favorite_level INTEGER DEFAULT 0, -- 現在のお気に入りレベル
    file_size INTEGER,                        -- ファイルサイズ（バイト）
    performer TEXT,                           -- 登場人物
    storage_location TEXT,                    -- 'C_DRIVE' or 'EXTERNAL_HDD'
    last_file_modified DATETIME,              -- ファイルの最終更新日時
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_scanned_at DATETIME,                 -- 最後にスキャンで検出された日時
    notes TEXT                                -- メモ欄（将来の拡張用）
);

-- インデックス
CREATE INDEX idx_essential_filename ON videos(essential_filename);
CREATE INDEX idx_favorite_level ON videos(current_favorite_level);
CREATE INDEX idx_performer ON videos(performer);
CREATE INDEX idx_storage_location ON videos(storage_location);
```

**カラム説明**:
- `essential_filename`: プレフィックス（`###_`, `##_`, `#_`, `_`）を除いたファイル名。ファイル移動やプレフィックス変更があっても同一性を保つための識別子。
- `current_full_path`: 現在の完全なファイルパス。スキャン時に更新される。
- `current_favorite_level`: 現在のお気に入りレベル（0=プレフィックスなし、1=#_、2=##_、3=###_、4以上も可能）
- `file_size`: ファイルサイズ。同名ファイルの判別補助に使用。
- `storage_location`: ファイルの保存場所（Cドライブまたは外付けHDD）

#### 2.1.2 viewing_history テーブル

視聴履歴を記録する。

```sql
CREATE TABLE viewing_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    video_id INTEGER NOT NULL,
    viewed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    viewing_method TEXT,  -- 'APP_PLAYBACK', 'MANUAL_ENTRY', 'FILE_ACCESS_DETECTED'
    FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE
);

-- インデックス
CREATE INDEX idx_video_id ON viewing_history(video_id);
CREATE INDEX idx_viewed_at ON viewing_history(viewed_at);
```

**カラム説明**:
- `video_id`: 視聴した動画のID（videosテーブルへの外部キー）
- `viewed_at`: 視聴日時
- `viewing_method`: 視聴記録の方法
  - `APP_PLAYBACK`: アプリ内の再生ボタン経由
  - `MANUAL_ENTRY`: ユーザーが手動で「視聴済み」を記録
  - `FILE_ACCESS_DETECTED`: ファイルアクセス検知による自動記録

#### 2.1.3 performers テーブル（将来の拡張用）

登場人物のマスタテーブル。現時点では未実装だが、スキーマは想定しておく。

```sql
CREATE TABLE performers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE video_performers (
    video_id INTEGER NOT NULL,
    performer_id INTEGER NOT NULL,
    PRIMARY KEY (video_id, performer_id),
    FOREIGN KEY (video_id) REFERENCES videos(id) ON DELETE CASCADE,
    FOREIGN KEY (performer_id) REFERENCES performers(id) ON DELETE CASCADE
);
```

※フェーズ1では`videos.performer`をTEXT型で簡易的に管理。フェーズ2以降で多対多リレーションに移行可能。

### 2.2 データベース接続管理

```python
# core/database.py
import sqlite3
from contextlib import contextmanager
from pathlib import Path

DATABASE_PATH = Path(__file__).parent.parent / "data" / "videos.db"

@contextmanager
def get_db_connection():
    """データベース接続のコンテキストマネージャ"""
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row  # 辞書形式でアクセス可能
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()
```

---

## 3. ファイル識別方式

### 3.1 課題と解決方針

**課題**:
- ファイルがCドライブ⇔外付けHDD間を移動する
- ディレクトリ構成が変わる可能性がある
- お気に入りレベルの変更に伴い、ファイル名のプレフィックスが変わる
  - 例: `###_作品名.mp4` → `##_作品名.mp4`

**解決方針**:
- **「本質的ファイル名（essential_filename）」を識別子として使用**
- プレフィックス（`###_`, `##_`, `#_`, `_`）を除いたファイル名をデータベースの一意キーとする
- ファイルサイズを副次的な判別要素として保持

### 3.2 本質的ファイル名の抽出ロジック

```python
# core/scanner.py
import re
from pathlib import Path

def extract_essential_filename(filename: str) -> tuple[int, str]:
    """
    ファイル名からお気に入りレベルと本質的ファイル名を抽出
    
    Args:
        filename: 元のファイル名（例: "###_作品名.mp4"）
    
    Returns:
        (favorite_level, essential_filename) のタプル
        例: (3, "作品名.mp4")
    """
    # プレフィックスパターン: 0個以上の#に続く_
    match = re.match(r'^(#{0,})_(.+)$', filename)
    
    if match:
        prefix = match.group(1)
        essential = match.group(2)
        level = len(prefix)  # #の個数 = お気に入りレベル
        return level, essential
    else:
        # プレフィックスがない場合
        return 0, filename

# 使用例
level, essential = extract_essential_filename("###_【俳優A】作品タイトル.mp4")
# level = 3
# essential = "【俳優A】作品タイトル.mp4"
```

### 3.3 ファイル同一性の判定

```python
def is_same_file(db_record: dict, file_path: Path) -> bool:
    """
    データベースのレコードと実ファイルが同一かを判定
    
    Args:
        db_record: データベースのレコード（essential_filename, file_size含む）
        file_path: 実ファイルのパス
    
    Returns:
        同一ファイルと判定されればTrue
    """
    _, essential = extract_essential_filename(file_path.name)
    file_size = file_path.stat().st_size
    
    # 本質的ファイル名が一致
    if db_record['essential_filename'] != essential:
        return False
    
    # ファイルサイズが一致（サイズが記録されている場合）
    if db_record.get('file_size') is not None:
        if abs(db_record['file_size'] - file_size) > 1024:  # 1KB以内の誤差を許容
            return False
    
    return True
```

### 3.4 エッジケースの対応

**ケース1: 同じ本質的ファイル名の異なるファイルが存在する場合**
- ファイルサイズで判別
- サイズも一致する場合は、ユーザーに確認を求める（UI上で選択）

**ケース2: ファイル名自体が変更された場合**
- フェーズ1では検出不可（手動で再登録が必要）
- フェーズ2でファイルハッシュによる識別を検討

---

## 4. 視聴履歴記録方式

### 4.1 記録方式の分類

視聴履歴を記録する方法を3つのパターンに分類し、段階的に実装する。

#### 4.1.1 方式A: アプリ内再生時の記録（最優先）

**実装フェーズ**: フェーズ1

**概要**: アプリ内の「再生」ボタンをクリックした際に確実に記録する。

**実装**:
```python
# core/video_manager.py
import subprocess
from datetime import datetime

def play_video(video_id: int, db_conn):
    """
    動画を再生し、視聴履歴を記録
    
    Args:
        video_id: 再生する動画のID
        db_conn: データベース接続
    """
    # 動画情報を取得
    cursor = db_conn.execute(
        "SELECT current_full_path FROM videos WHERE id = ?",
        (video_id,)
    )
    video = cursor.fetchone()
    
    if not video:
        raise ValueError(f"Video ID {video_id} not found")
    
    # デフォルトプレイヤーで再生
    subprocess.Popen(['start', '', video['current_full_path']], shell=True)
    
    # 視聴履歴を記録
    db_conn.execute(
        """
        INSERT INTO viewing_history (video_id, viewed_at, viewing_method)
        VALUES (?, ?, 'APP_PLAYBACK')
        """,
        (video_id, datetime.now())
    )
    db_conn.commit()
```

#### 4.1.2 方式B: ファイルアクセス検知による記録（推奨）

**実装フェーズ**: フェーズ1

**概要**: 定期的にファイルの「最終アクセス日時」をチェックし、前回チェック以降にアクセスされたファイルを検出する。

**利点**:
- エクスプローラから直接再生した場合も記録できる
- 実装が比較的シンプル
- 常駐プロセス不要

**制約**:
- リアルタイム記録ではない（スキャン間隔に依存）
- アクセス日時の精度に依存（Windows標準では日付のみの場合がある）

**実装**:
```python
# core/scanner.py
from datetime import datetime, timedelta
from pathlib import Path

def scan_for_recently_accessed_files(
    scan_directories: list[Path],
    last_scan_time: datetime,
    db_conn
) -> list[dict]:
    """
    最終スキャン以降にアクセスされたファイルを検出
    
    Args:
        scan_directories: スキャン対象ディレクトリのリスト
        last_scan_time: 前回のスキャン日時
        db_conn: データベース接続
    
    Returns:
        新たにアクセスされたファイルの情報リスト
    """
    newly_accessed = []
    
    for directory in scan_directories:
        for file_path in directory.rglob("*.mp4"):  # 動画拡張子で検索
            try:
                # ファイルの最終アクセス日時を取得
                access_time = datetime.fromtimestamp(file_path.stat().st_atime)
                
                # 前回スキャン以降にアクセスされている場合
                if access_time > last_scan_time:
                    _, essential = extract_essential_filename(file_path.name)
                    
                    # データベースから対応する動画を検索
                    cursor = db_conn.execute(
                        "SELECT id FROM videos WHERE essential_filename = ?",
                        (essential,)
                    )
                    video = cursor.fetchone()
                    
                    if video:
                        newly_accessed.append({
                            'video_id': video['id'],
                            'file_path': str(file_path),
                            'access_time': access_time
                        })
            except Exception as e:
                print(f"Error processing {file_path}: {e}")
                continue
    
    return newly_accessed

def record_file_access_as_viewing(accessed_files: list[dict], db_conn):
    """
    ファイルアクセスを視聴履歴として記録（ユーザー確認後）
    
    Args:
        accessed_files: アクセスされたファイルのリスト
        db_conn: データベース接続
    """
    for file_info in accessed_files:
        db_conn.execute(
            """
            INSERT INTO viewing_history (video_id, viewed_at, viewing_method)
            VALUES (?, ?, 'FILE_ACCESS_DETECTED')
            """,
            (file_info['video_id'], file_info['access_time'])
        )
    db_conn.commit()
```

**運用フロー**:
1. アプリ起動時、または定期的（1日1回など）にスキャン実行
2. 新たにアクセスされたファイルをリストアップ
3. UI上でユーザーに確認（「これらのファイルを視聴済みとして記録しますか？」）
4. ユーザー承認後、視聴履歴に追加

#### 4.1.3 方式C: 手動記録機能（補完）

**実装フェーズ**: フェーズ1

**概要**: ユーザーが明示的に「視聴済みにする」ボタンをクリックして記録する。

**実装**:
```python
# core/video_manager.py
def mark_as_viewed(video_id: int, db_conn):
    """
    動画を視聴済みとして手動記録
    
    Args:
        video_id: 記録する動画のID
        db_conn: データベース接続
    """
    db_conn.execute(
        """
        INSERT INTO viewing_history (video_id, viewed_at, viewing_method)
        VALUES (?, ?, 'MANUAL_ENTRY')
        """,
        (video_id, datetime.now())
    )
    db_conn.commit()
```

#### 4.1.4 方式D: ファイルシステム監視（将来の拡張）

**実装フェーズ**: フェーズ2以降

**概要**: `watchdog`ライブラリを使用してファイルアクセスをリアルタイムで監視する。

**利点**:
- リアルタイムで記録可能
- エクスプローラ再生も自動検知

**制約**:
- 常駐プロセスが必要
- リソース消費が増加

### 4.2 実装優先度

フェーズ1では以下の順で実装：

1. **方式A（アプリ内再生）**: 必須、確実に動作
2. **方式C（手動記録）**: 必須、フォールバック手段
3. **方式B（ファイルアクセス検知）**: 推奨、実装難易度は中程度

方式Dはフェーズ2以降で検討する。

---

## 5. コアモジュール設計

### 5.1 モジュール構成

```
project_root/
├── streamlit_app.py          # UI層（Streamlit）
├── config.py                 # 設定ファイル
├── core/                     # コア層
│   ├── __init__.py
│   ├── database.py           # データベースアクセス
│   ├── models.py             # データモデル定義
│   ├── scanner.py            # ファイルスキャン
│   └── video_manager.py      # 動画管理ロジック
├── data/                     # データ保存ディレクトリ
│   └── videos.db             # SQLiteデータベース
└── tests/                    # テストコード
    ├── test_scanner.py
    └── test_video_manager.py
```

### 5.2 主要クラス設計

#### 5.2.1 Video クラス

```python
# core/models.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class Video:
    """動画データモデル"""
    id: Optional[int]
    essential_filename: str
    current_full_path: str
    current_favorite_level: int
    file_size: Optional[int]
    performer: Optional[str]
    storage_location: str  # 'C_DRIVE' or 'EXTERNAL_HDD'
    last_file_modified: Optional[datetime]
    created_at: Optional[datetime]
    last_scanned_at: Optional[datetime]
    notes: Optional[str] = None
    
    @property
    def display_name(self) -> str:
        """表示用のファイル名（プレフィックス付き）"""
        prefix = '#' * self.current_favorite_level + '_' if self.current_favorite_level > 0 else '_'
        return f"{prefix}{self.essential_filename}"
```

#### 5.2.2 VideoManager クラス

```python
# core/video_manager.py
from typing import List, Optional
from core.models import Video
from core.database import get_db_connection

class VideoManager:
    """動画管理のビジネスロジック"""
    
    def get_videos(
        self,
        favorite_levels: Optional[List[int]] = None,
        performers: Optional[List[str]] = None,
        storage_locations: Optional[List[str]] = None
    ) -> List[Video]:
        """フィルタ条件に合致する動画を取得"""
        with get_db_connection() as conn:
            query = "SELECT * FROM videos WHERE 1=1"
            params = []
            
            if favorite_levels:
                placeholders = ','.join('?' * len(favorite_levels))
                query += f" AND current_favorite_level IN ({placeholders})"
                params.extend(favorite_levels)
            
            if performers:
                placeholders = ','.join('?' * len(performers))
                query += f" AND performer IN ({placeholders})"
                params.extend(performers)
            
            if storage_locations:
                placeholders = ','.join('?' * len(storage_locations))
                query += f" AND storage_location IN ({placeholders})"
                params.extend(storage_locations)
            
            cursor = conn.execute(query, params)
            rows = cursor.fetchall()
            
            return [Video(**dict(row)) for row in rows]
    
    def get_random_video(
        self,
        favorite_levels: Optional[List[int]] = None,
        performers: Optional[List[str]] = None
    ) -> Optional[Video]:
        """ランダムに1本選択"""
        videos = self.get_videos(favorite_levels, performers)
        
        if not videos:
            return None
        
        import random
        return random.choice(videos)
    
    def play_video(self, video_id: int):
        """動画を再生し、視聴履歴を記録"""
        # 前述の実装参照
        pass
    
    def get_viewing_stats(self) -> dict:
        """視聴統計を取得"""
        with get_db_connection() as conn:
            # 視聴回数ランキング
            cursor = conn.execute("""
                SELECT v.id, v.essential_filename, COUNT(vh.id) as view_count
                FROM videos v
                LEFT JOIN viewing_history vh ON v.id = vh.video_id
                GROUP BY v.id
                ORDER BY view_count DESC
                LIMIT 20
            """)
            top_viewed = cursor.fetchall()
            
            # よく見るけど最近見ていない動画
            cursor = conn.execute("""
                SELECT v.id, v.essential_filename, 
                       COUNT(vh.id) as view_count,
                       MAX(vh.viewed_at) as last_viewed
                FROM videos v
                LEFT JOIN viewing_history vh ON v.id = vh.video_id
                GROUP BY v.id
                HAVING view_count >= 5 
                   AND (last_viewed IS NULL OR last_viewed < datetime('now', '-30 days'))
                ORDER BY view_count DESC
            """)
            forgotten_favorites = cursor.fetchall()
            
            return {
                'top_viewed': [dict(row) for row in top_viewed],
                'forgotten_favorites': [dict(row) for row in forgotten_favorites]
            }
```

#### 5.2.3 FileScanner クラス

```python
# core/scanner.py
from pathlib import Path
from typing import List
from core.models import Video
from core.database import get_db_connection

class FileScanner:
    """ファイルスキャンとデータベース更新"""
    
    def __init__(self, scan_directories: List[Path]):
        self.scan_directories = scan_directories
    
    def scan_and_update(self):
        """ファイルをスキャンしてデータベースを更新"""
        with get_db_connection() as conn:
            for directory in self.scan_directories:
                self._scan_directory(directory, conn)
    
    def _scan_directory(self, directory: Path, conn):
        """ディレクトリをスキャン"""
        for file_path in directory.rglob("*.mp4"):  # 動画拡張子
            self._process_file(file_path, conn)
    
    def _process_file(self, file_path: Path, conn):
        """個別ファイルの処理"""
        # お気に入りレベルと本質的ファイル名を抽出
        level, essential = extract_essential_filename(file_path.name)
        
        # ファイル情報を取得
        file_size = file_path.stat().st_size
        storage_location = self._determine_storage_location(file_path)
        performer = self._extract_performer(file_path)
        
        # データベースに既存レコードがあるか確認
        cursor = conn.execute(
            "SELECT * FROM videos WHERE essential_filename = ?",
            (essential,)
        )
        existing = cursor.fetchone()
        
        if existing:
            # 更新
            conn.execute("""
                UPDATE videos
                SET current_full_path = ?,
                    current_favorite_level = ?,
                    storage_location = ?,
                    last_scanned_at = CURRENT_TIMESTAMP
                WHERE essential_filename = ?
            """, (str(file_path), level, storage_location, essential))
        else:
            # 新規追加
            conn.execute("""
                INSERT INTO videos (
                    essential_filename, current_full_path, current_favorite_level,
                    file_size, performer, storage_location, last_scanned_at
                )
                VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            """, (essential, str(file_path), level, file_size, performer, storage_location))
    
    def _determine_storage_location(self, file_path: Path) -> str:
        """ファイルの保存場所を判定"""
        # Cドライブかどうかを判定
        if file_path.drive == 'C:':
            return 'C_DRIVE'
        else:
            return 'EXTERNAL_HDD'
    
    def _extract_performer(self, file_path: Path) -> Optional[str]:
        """登場人物を抽出（フォルダ名またはファイル名から）"""
        # 親ディレクトリ名を登場人物として扱う（暫定実装）
        # より高度な抽出ロジックは将来実装
        return file_path.parent.name
```

---

## 6. 処理フロー

### 6.1 初回起動時のフロー

```
1. データベース初期化
   ├─ テーブル作成（videos, viewing_history）
   └─ インデックス作成

2. 設定読み込み
   ├─ スキャン対象ディレクトリの読み込み
   └─ デフォルト設定の適用

3. ファイルスキャン
   ├─ Cドライブの指定ディレクトリをスキャン
   ├─ 外付けHDD（接続時）の指定ディレクトリをスキャン
   ├─ 各ファイルの情報をデータベースに登録
   └─ 進捗表示

4. UI起動
   └─ Streamlitアプリケーション起動
```

### 6.2 動画再生フロー

```
[ユーザー操作: 再生ボタンクリック]
    ↓
1. video_id取得
    ↓
2. データベースから動画情報を取得
    ↓
3. ファイルの存在確認
    ├─ 存在する → 再生処理へ
    └─ 存在しない → エラー表示、再スキャン提案
    ↓
4. デフォルトプレイヤーで再生
    ↓
5. 視聴履歴をデータベースに記録
    ├─ video_id
    ├─ viewed_at (現在時刻)
    └─ viewing_method = 'APP_PLAYBACK'
    ↓
6. UI更新（視聴回数などの表示更新）
```

### 6.3 ファイルアクセス検知フロー

```
[トリガー: アプリ起動時 or 手動実行]
    ↓
1. 前回スキャン日時を取得
    ↓
2. 対象ディレクトリをスキャン
    ├─ 各ファイルの最終アクセス日時を取得
    └─ 前回スキャン以降にアクセスされたファイルをリストアップ
    ↓
3. アクセスされたファイルをUI表示
    ├─ ファイル名一覧
    └─ アクセス日時
    ↓
4. ユーザー確認
    ├─ 「すべて視聴済みにする」
    ├─ 「選択して視聴済みにする」
    └─ 「キャンセル」
    ↓
5. 選択されたファイルを視聴履歴に記録
    └─ viewing_method = 'FILE_ACCESS_DETECTED'
    ↓
6. 最終スキャン日時を更新
```

### 6.4 ランダム再生フロー

```
[ユーザー操作: ランダム再生ボタンクリック]
    ↓
1. フィルタ条件を取得
    ├─ お気に入りレベル
    ├─ 登場人物
    └─ 保存場所
    ↓
2. 条件に合致する動画をデータベースから取得
    ↓
3. 取得結果の確認
    ├─ 動画あり → ランダム選択へ
    └─ 動画なし → 「該当する動画がありません」表示
    ↓
4. Python random.choice()でランダムに1本選択
    ↓
5. 選択された動画情報を表示
    ├─ ファイル名
    ├─ お気に入りレベル
    └─ 視聴回数
    ↓
6. 再生確認
    ├─ 「再生する」→ 再生フローへ
    └─ 「別の動画を選ぶ」→ ステップ4へ戻る
```

---

## 7. エラーハンドリング

### 7.1 ファイルが見つからない場合

**発生状況**: 再生時にファイルパスが無効

**対応**:
```python
def play_video_with_error_handling(video_id: int, db_conn):
    """エラーハンドリング付き再生処理"""
    cursor = db_conn.execute(
        "SELECT * FROM videos WHERE id = ?",
        (video_id,)
    )
    video = cursor.fetchone()
    
    if not video:
        raise ValueError("動画が見つかりません")
    
    file_path = Path(video['current_full_path'])
    
    if not file_path.exists():
        # ファイルが存在しない場合の対応
        return {
            'status': 'error',
            'message': 'ファイルが見つかりません。ファイルが移動または削除された可能性があります。',
            'suggestions': [
                '再スキャンを実行してデータベースを更新してください',
                '外付けHDDが接続されているか確認してください'
            ]
        }
    
    # 再生処理
    subprocess.Popen(['start', '', str(file_path)], shell=True)
    
    # 視聴履歴記録
    record_viewing(video_id, db_conn)
    
    return {'status': 'success'}
```

### 7.2 外付けHDD未接続の場合

**対応**:
- UI上で外付けHDD上のファイルには「HDD」マークを表示
- 再生時にHDD未接続の場合は「外付けHDDを接続してください」と表示
- フィルタで「Cドライブのみ」を選択可能に

### 7.3 データベース破損の場合

**対応**:
- データベースファイルのバックアップを定期的に作成（週次）
- 起動時にデータベースの整合性チェック
- 破損検出時はバックアップからの復元オプションを提示

---

## 8. 設定管理

### 8.1 config.py

```python
# config.py
from pathlib import Path

# スキャン対象ディレクトリ
SCAN_DIRECTORIES = [
    Path("C:/Users/YourName/Videos"),
    Path("E:/Videos"),  # 外付けHDD（ドライブレター要確認）
]

# データベースパス
DATABASE_PATH = Path(__file__).parent / "data" / "videos.db"

# 対応する動画拡張子
VIDEO_EXTENSIONS = ['.mp4', '.avi', '.mkv', '.mov', '.wmv']

# お気に入りレベルの表示名
FAVORITE_LEVEL_NAMES = {
    0: '通常',
    1: 'やや気に入っている',
    2: 'お気に入り',
    3: '最もお気に入り',
    4: '超お気に入り',  # 将来の拡張
}

# ファイルアクセス検知の閾値
FILE_ACCESS_DETECTION_DAYS = 1  # 前回スキャンから何日以内のアクセスを検知するか
```

---

## 9. テスト戦略

### 9.1 ユニットテスト

```python
# tests/test_scanner.py
import pytest
from core.scanner import extract_essential_filename

def test_extract_essential_filename_with_prefix():
    """プレフィックス付きファイル名の抽出"""
    level, essential = extract_essential_filename("###_作品名.mp4")
    assert level == 3
    assert essential == "作品名.mp4"

def test_extract_essential_filename_without_prefix():
    """プレフィックスなしファイル名の抽出"""
    level, essential = extract_essential_filename("作品名.mp4")
    assert level == 0
    assert essential == "作品名.mp4"

def test_extract_essential_filename_single_sharp():
    """単一#のファイル名"""
    level, essential = extract_essential_filename("#_作品名.mp4")
    assert level == 1
    assert essential == "作品名.mp4"
```

### 9.2 統合テスト

- データベースへの登録・更新処理のテスト
- フィルタリング機能のテスト
- 視聴履歴記録のテスト

---

## 10. パフォーマンス考慮事項

### 10.1 スキャン処理の最適化

**課題**: 2000ファイルのスキャンに時間がかかる可能性

**対策**:
- 初回スキャン時は時間がかかることを想定（進捗バー表示）
- 2回目以降は差分スキャンのみ実施
- `last_scanned_at`を活用し、未スキャンまたは変更されたファイルのみ処理

### 10.2 データベースクエリの最適化

- 頻繁に検索されるカラムにインデックスを作成済み
- フィルタリング時のIN句使用でパフォーマンス確保
- 必要に応じてクエリ結果のキャッシング（Streamlit st.cache活用）

---

## 11. セキュリティ考慮事項

### 11.1 SQLインジェクション対策

- プレースホルダ（`?`）を使用したパラメータバインディング
- ユーザー入力を直接SQL文字列に連結しない

```python
# 良い例
cursor.execute("SELECT * FROM videos WHERE id = ?", (video_id,))

# 悪い例（使用禁止）
cursor.execute(f"SELECT * FROM videos WHERE id = {video_id}")
```

### 11.2 ファイルパスの検証

- ファイルパスの妥当性検証（ディレクトリトラバーサル対策）
- 許可されたディレクトリ内のファイルのみアクセス

### 11.3 データの外部送信禁止

- すべてのデータ処理をローカル完結
- ネットワーク通信を行うコードは含まない
- サードパーティライブラリの選定時も確認

---

## 12. 今後の拡張ロードマップ

### フェーズ2（中期）
- Flask/FastAPI + HTML/JS への移行
- サムネイル自動抽出・表示
- 気分タグ機能の実装
- より詳細な統計ダッシュボード

### フェーズ3（長期）
- プレイリスト機能
- 複数登場人物への対応（多対多リレーション）
- 機械学習による推薦機能
- 時間帯・曜日の視聴傾向分析

---

**変更履歴**

| バージョン | 日付 | 変更内容 |
|----------|------|---------|
| 1.0 | 2026-01-01 | 初版作成 |
